#!/usr/bin/env python3

from queue import Queue
from curses import wrapper
import curses
import sys

from collections import defaultdict as dd

MAP_HEIGHT = 75
MAP_WIDTH = 75
# TODO Center Window
WIN_X = 0
WIN_Y = 0

def neighbors(current, obstacles):
    neighbors = []
    if current[0] - 1 >= 0 and (current[0] - 1, current[1]) not in obstacles:
        neighbors += [(current[0] - 1, current[1])]
    if current[0] + 1 <= MAP_WIDTH - 1 and (current[0] + 1, current[1]) not in obstacles:
        neighbors += [(current[0] + 1, current[1])]
    if current[1] - 1 >= 0 and (current[0], current[1] - 1) not in obstacles:
        neighbors += [(current[0], current[1] - 1)]
    if current[1] + 1 <= MAP_HEIGHT - 1 and (current[0], current[1] + 1) not in obstacles:
        neighbors += [(current[0], current[1] + 1)]

    return neighbors


def path_find(start, end, obstacles):
    frontier = Queue()
    frontier.put(start)

    came_from = {}
    came_from[start] = None

    print(start, file=sys.stderr)
    print(end, file=sys.stderr)
    # print(obstacles, file=sys.stderr)
    while not frontier.empty():
        current = frontier.get()
        # print(current, file=sys.stderr)
        # print(came_from, file=sys.stderr)
        # print(frontier, file=sys.stderr)
        if current == end:
            break
        print(neighbors(current, obstacles), file=sys.stderr)
        for next in neighbors(current, obstacles):
            # print(next_f, file=sys.stderr)
            if next not in came_from:
                frontier.put(next)
                came_from[next] = current

    current = end
    path = []
    # print(came_from, file=sys.stderr)
    while current != start:
        path = [current] + path
        # print(path, file=sys.stderr)
        current = came_from[current]

    return path

class GameManager():
    def __init__(self, gameObjects = {}):
        self.gameObjects = gameObjects
        self.turn = 0

    def start():
        read(json)

        while True:
            turn += 1

def get_points_of_rooms(rooms):
    points = []
    for room in rooms:
        # for door in room.doors:
        #     points += [door]
        for tiles in room.tiles:
            points += [tiles]
        for wall in room.walls:
            points += [wall]

    return points

class Board():
    def __init__(self, rooms, association_of_doors):
        self.rooms = rooms

        self.obstacles = get_points_of_rooms(self.rooms)

        self.hallways = []
        for association in association_of_doors:
            hallway = Hallway((association[0].x, association[0].y),
                              (association[1].x, association[1].y),
                              self.obstacles)
            self.hallways += [hallway]

        self.all = {}
        for room in self.rooms:
            # self.all = dict(self.all + room.doors.items() + room.tiles.items() + room.walls.items())
            self.all.update(room.doors)
            self.all.update(room.tiles)
            self.all.update(room.walls)
        for hallway in self.hallways:
            # self.all = dict(self.all + hallway.tiles.items())
            self.all.update(hallway.tiles)


class Hallway():
    def __init__(self, start, end, obstacles):
        self.tiles = {}
        for point in path_find(start, end, obstacles):
            tile = Tile(point[0], point[1])
            tile.setSym("%")
            self.tiles[(point[0], point[1])] = tile

class Room():
    def __init__(self, x, y, width, height, doors):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

        self.doors = {}
        for door in doors:
            self.doors[(door.x, door.y)] = door

        print(self.doors, file=sys.stderr)
        self.walls = {}
        for x in range(self.x, self.x + width):
            if (x, self.y) not in self.doors:
                wall = Wall(x, self.y)
                self.walls[(x, self.y)] = wall

            if (x, self.y + height - 1) not in self.doors:
                wall = Wall(x, self.y + height - 1)
                self.walls[(x, self.y + height - 1)] = wall

        for y in range(self.y, self.y + height):
            if (self.x, y) not in self.doors:
                wall = Wall(self.x, y)
                self.walls[(self.x, y)] = wall

            if (self.x + width - 1, y) not in self.doors:
                wall = Wall(self.x + width - 1, y)
                self.walls[(self.x + width - 1, y)] = wall

        self.tiles = {}
        for x in range(self.x + 1, self.x + width - 1):
            for y in range(self.y + 1, self.y + height - 1):
                tile = Tile(x, y)
                self.tiles[(x, y)] = tile


def main(stdscr):
    stdscr.clear()

    print(curses.COLS, file=sys.stderr)
    print(curses.LINES, file=sys.stderr)
    if curses.COLS < MAP_WIDTH - 1 or curses.LINES < MAP_HEIGHT - 1:
        print("Terminal Too Small", file=sys.stderr)
        sys.exit(-1)

    curses.curs_set(0)
    win = curses.newwin(MAP_HEIGHT, MAP_WIDTH, WIN_Y, WIN_X)
    win.keypad(True)

    doorA = Door(18, 39)
    doorB = Door(55, 60)

    roomA = Room(0, 0, 30, 40, [doorA])
    roomB = Room(50, 60, 10, 10, [doorB])

    board = Board([roomA, roomB], [(doorA, doorB)])
    # board = Board([roomA], [(doorA, doorB)])

    y, x = 10, 1
    while True:
        win.erase()

        for _, gameObject in board.all.items():
            print(gameObject.x, file=sys.stderr)
            print(gameObject.y, file=sys.stderr)
            win.addstr(gameObject.y, gameObject.x, gameObject.sym)

        # for _, wall in room.walls.items():
        #     win.addstr(wall.y, wall.x, wall.sym)
        # for _, tile in room.tiles.items():
        #     win.addstr(tile.y, tile.x, tile.sym)
        # for _, door in room.doors.items():
        #     win.addstr(door.y, door.x, door.sym)


        win.addstr(y, x, "\u263b")
        win.refresh()
        key = win.getch()
        if key == curses.KEY_LEFT:
            if x > 1:
                x -= 1
        elif key == curses.KEY_RIGHT:
            if x < MAP_WIDTH - 2:
                x += 1
            x += 1
        elif key == curses.KEY_UP:
            if y > 1:
                y -= 1
        elif key == curses.KEY_DOWN:
            if y < MAP_HEIGHT - 2:
                y += 1


if __name__ == "__main__":
    wrapper(main)
